/* Generated By:JJTree&JavaCC: Do not edit this line. RuleParser.java */
    package com.oxymedical.component.rulesComponent.parser.javacc;
    
    import java.util.ArrayList;
    import java.util.List;

import com.oxymedical.component.rulesComponent.ICondition;
import com.oxymedical.component.rulesComponent.IConsequence;
import com.oxymedical.component.rulesComponent.IRule;
import com.oxymedical.component.rulesComponent.IVariables;
import com.oxymedical.component.rulesComponent.rule.elements.Condition;
import com.oxymedical.component.rulesComponent.rule.elements.Consequence;
import com.oxymedical.component.rulesComponent.rule.elements.Rule;
import com.oxymedical.component.rulesComponent.rule.elements.RuleSet;
import com.oxymedical.component.rulesComponent.rule.elements.Variables;

    
    /**
     * This is the generated class by javacc jjtree.
     * Code to set values in RuleSet object has been appended to this class.
     * Whenever RuleParser.jjt is compiled with javacc, all the generated class code gets changed
     * Hence the code appended to this class also needs to be rewritten.  
     * 
     * @author Oxyent Medical
     *
     */    
    public class RuleParser/*@bgen(jjtree)*/implements RuleParserTreeConstants, RuleParserConstants {/*@bgen(jjtree)*/
    	protected JJTRuleParserState jjtree = new JJTRuleParserState();
  
	  public RuleSet ruleSet = new RuleSet();
	
	  public RuleSet getRuleSet() {
	  	return ruleSet;
	  }
	
	  public void setRuleSet(RuleSet ruleSet) {
	  	this.ruleSet = ruleSet;
	  }

  final public SimpleNode parse() throws ParseException {
     /*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case openrulesetattr:
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        ruleSetLine();
      }
      jj_consume_token(0);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

        // a ruleset consists of a variable list and a rule list
  final public void ruleSetLine() throws ParseException {
     /*@bgen(jjtree) ruleSetLine */
     SimpleNode jjtn000 = new SimpleNode(JJTRULESETLINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        exitLine();
      }
      jj_consume_token(openrulesetattr);
      t = jj_consume_token(WORD);
      String ruleSetName = t.image;
      ruleSet.setName(ruleSetName);
      jj_consume_token(RA);
      variablesList();
      ruleList();
      jj_consume_token(endruleset);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

    // variable list consists of number of variables 
  final public void variablesList() throws ParseException {
	  List<IVariables> variableList = new ArrayList<IVariables>();	 
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      exitLine();
    }
    jj_consume_token(openvariables);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case openvariable:
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_5;
      }
      IVariables var = variable();
      variableList.add(var);
    }
    jj_consume_token(endvariables);
    ruleSet.setVariables(variableList);  
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_6;
      }
      exitLine();
    }
  }

    // Each variable has a type and an id    
  final public IVariables variable() throws ParseException {
     /*@bgen(jjtree) variable */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLE);
  boolean jjtc000 = true;
  Variables var = new Variables();
  jjtree.openNodeScope(jjtn000);
    try {
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_7;
        }
        exitLine();
      }
      jj_consume_token(openvariable);
      String variableType = type();
      var.setType(variableType);
      String variableId = id();
      var.setId(variableId);
      jj_consume_token(endvariable);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_8;
        }
        exitLine();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return var;
  }

        // type consists of a word
  final public String type() throws ParseException {
     /*@bgen(jjtree) type */
     SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
     boolean jjtc000 = true;
     String result = "";
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_9;
        }
        exitLine();
      }
      jj_consume_token(openType);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_10;
        }
        exitLine();
      }
      t = jj_consume_token(WORD);
      result = t.image;
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_11;
        }
        exitLine();
      }
      jj_consume_token(endType);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_12;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return result;
  }

        // id consists of a word
  final public String id() throws ParseException {
     /*@bgen(jjtree) id */
     SimpleNode jjtn000 = new SimpleNode(JJTID);
     boolean jjtc000 = true;
     String result = "";
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_13;
        }
        exitLine();
      }
      jj_consume_token(openID);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_14;
        }
        exitLine();
      }
      t = jj_consume_token(WORD);
      result = t.image;
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_15;
        }
        exitLine();
      }
      jj_consume_token(endID);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_16;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return result;
  }

        // rule list has number of rules
  final public void ruleList() throws ParseException {
	  List<IRule> rulesList = new ArrayList<IRule>();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case openruleattr:
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_17;
      }
      IRule rule = ruleLine();
      rulesList.add(rule);
    }
	  ruleSet.setRules(rulesList);
  }

        // each rule has a name which is unique across the rule set and consists of an if line and then line
  final public IRule ruleLine() throws ParseException {
     /*@bgen(jjtree) ruleLine */
     SimpleNode jjtn000 = new SimpleNode(JJTRULELINE);
     boolean jjtc000 = true;
     IRule rule = new Rule();
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_18;
        }
        exitLine();
      }
      jj_consume_token(openruleattr);
      t = jj_consume_token(WORD);
      rule.setName(t.image);
      jj_consume_token(RA);
      int salience = salienceLine();
      rule.setSalience(salience);
      ICondition condition = ifLine();
      rule.setCondition(condition);
      List<IConsequence> consequenceList = thenLine();
      rule.setConsequenceList(consequenceList);
      String url = urlLine();
      rule.setUrl(url);
      jj_consume_token(endrule);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_19;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return rule;
  }

    // if line has a list of conditions
  final public int salienceLine() throws ParseException {
     /*@bgen(jjtree) salienceLine */
     SimpleNode jjtn000 = new SimpleNode(JJTSALIENCELINE);
     boolean jjtc000 = true;
     int salience = 0;
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_20;
        }
        exitLine();
      }
      jj_consume_token(opensalience);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_21;
        }
        exitLine();
      }
      t = jj_consume_token(WORD);
      String tempSalience = t.image;
      tempSalience = tempSalience.trim();
      if (null != tempSalience && !(" ").equals(tempSalience) && tempSalience.length() > 0)
    	  salience = Integer.parseInt(tempSalience);
      
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_22;
        }
        exitLine();
      }
      jj_consume_token(endsalience);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_23;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return salience;
  }

        // if line has a list of conditions
  final public ICondition ifLine() throws ParseException {
     /*@bgen(jjtree) ifLine */
  SimpleNode jjtn000 = new SimpleNode(JJTIFLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  ICondition cond = new Condition();
    try {
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_24;
        }
        exitLine();
      }
      jj_consume_token(openif);
      cond = conditionList();
      jj_consume_token(endif);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_25;
        }
        exitLine();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return cond;
  }

        // Condition list consists of number of conditions
  final public ICondition conditionList() throws ParseException {
	  ICondition cond = new Condition();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_26;
      }
      exitLine();
    }
    jj_consume_token(openconditionlist);
    String conditionString = condition();
    cond.setConditionString(conditionString);
    jj_consume_token(endconditionlist);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_27;
      }
      exitLine();
    }
    return cond;
  }

    // Each condition has a name and consists of word which defines complex conditions   
  final public String condition() throws ParseException {
     /*@bgen(jjtree) condition */
     SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
     boolean jjtc000 = true;
     String result = "";
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_28;
        }
        exitLine();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case opencondition:
        jj_consume_token(opencondition);
        break;
      case openconditionattr:
        jj_consume_token(openconditionattr);
        jj_consume_token(WORD);
        jj_consume_token(RA);
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_29;
        }
        exitLine();
      }
      t = jj_consume_token(WORD);
      result = t.image;
      label_30:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_30;
        }
        exitLine();
      }
      jj_consume_token(endcondition);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_31;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return result;
  }

    // Then line consists of list of consequences
  final public List<IConsequence> thenLine() throws ParseException {
     /*@bgen(jjtree) thenLine */
  SimpleNode jjtn000 = new SimpleNode(JJTTHENLINE);
  boolean jjtc000 = true;
  List<IConsequence> consqList = new ArrayList<IConsequence>(); 
  jjtree.openNodeScope(jjtn000);
    try {
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_32;
        }
        exitLine();
      }
      jj_consume_token(openthen);
      consqList = consequenceList();
      jj_consume_token(endthen);
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_33;
        }
        exitLine();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return consqList;
  }

        // consequences list consists of number of consequences
  final public List<IConsequence> consequenceList() throws ParseException {
	  List<IConsequence> consequenceList = new ArrayList<IConsequence>();	 
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_34;
      }
      exitLine();
    }
    jj_consume_token(openconsequencelist);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case openconsequence:
      case openconsequenceattr:
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_35;
      }
      IConsequence conseq = consequenceLine();
      consequenceList.add(conseq);
    }
    jj_consume_token(endconsequencelist);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPC:
      case CRLF:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_36;
      }
      exitLine();
    }
    return consequenceList;
  }

  final public IConsequence consequenceLine() throws ParseException {
		Consequence conseq = new Consequence();
	    String consequenceString = consequence();
	    conseq.setConsequenceString(consequenceString);
	    return conseq;
  }

        // Each consequence has a name and consists of word that defines the consequence to be executed when the condition is satisfied
  final public String consequence() throws ParseException {
     /*@bgen(jjtree) consequence */
     SimpleNode jjtn000 = new SimpleNode(JJTCONSEQUENCE);
     boolean jjtc000 = true;
     String result = "";
     jjtree.openNodeScope(jjtn000);Token t;
    try {
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_37;
        }
        exitLine();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case openconsequence:
        jj_consume_token(openconsequence);
        break;
      case openconsequenceattr:
        jj_consume_token(openconsequenceattr);
        jj_consume_token(WORD);
        jj_consume_token(RA);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_38:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_38;
        }
        exitLine();
      }
      t = jj_consume_token(WORD);
      result = t.image;
      label_39:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_39;
        }
        exitLine();
      }
      jj_consume_token(endconsequence);
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_40;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return result;
  }

  final public String urlLine() throws ParseException {
     /*@bgen(jjtree) urlLine */
     SimpleNode jjtn000 = new SimpleNode(JJTURLLINE);
     boolean jjtc000 = true;
     String result="";
     jjtree.openNodeScope(jjtn000);Token t=new Token();
    try {
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_41;
        }
        exitLine();
      }
      jj_consume_token(openurl);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        t = jj_consume_token(WORD);
        if (null != t.image)
        	result = t.image;
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      jj_consume_token(endurl);
      label_42:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPC:
        case CRLF:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_42;
        }
        exitLine();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setToken(t.kind, t.image);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    return result;
  }

    // Exit line defines the terminating characters or characters to be ignored in a rule
  final public void exitLine() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SPC:
      jj_consume_token(SPC);
      break;
    case CRLF:
      jj_consume_token(CRLF);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public RuleParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[46];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x100,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x0,0x6000,0x6000,0x6000,0x6000,0x6000,0x6000,0x6300,0x6000,0x6000,0x300,0x6000,0x6000,0x6000,0x6000,0x1000,0x6000,0x6000,};
   }

  public RuleParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public RuleParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RuleParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public RuleParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RuleParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public RuleParser(RuleParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  public void ReInit(RuleParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 46; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[48];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 46; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 48; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

                            };
