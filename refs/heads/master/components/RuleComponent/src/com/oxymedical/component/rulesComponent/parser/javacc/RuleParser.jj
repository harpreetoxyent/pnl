/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\RuleParser.jj */
/*@egen*/options 
    {                    
      STATIC=false;               
    }


    PARSER_BEGIN( RuleParser )
    package com.oxymedical.component.rulesComponent.parser.javacc;    
    public class RuleParser/*@bgen(jjtree)*/implements RuleParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTRuleParserState jjtree = new JJTRuleParserState();

/*@egen*/}; 
    PARSER_END( RuleParser )


    SimpleNode parse(): 
    {/*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
    {/*@bgen(jjtree) parse */
        try {
/*@egen*/ 
	( ruleSetLine() )* <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 	
	{		
		return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
    }   

	// a ruleset consists of a variable list and a rule list
    void ruleSetLine():
    {/*@bgen(jjtree) ruleSetLine */
     SimpleNode jjtn000 = new SimpleNode(JJTRULESETLINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) ruleSetLine */
        try {
/*@egen*/ 
	( (exitLine())* (<openrulesetattr> t=<WORD> <RA>) variablesList() ruleList() <endruleset> (exitLine())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/	
	{
		jjtn000.setToken(t.kind, t.image); 
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
   
    // variable list consists of number of variables 
    void variablesList()       :
    {}
    { 
	( (exitLine())* <openvariables> (variable())* <endvariables> (exitLine())* )
    }
      
    // Each variable has a type and an id    
    void variable():
    {/*@bgen(jjtree) variable */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
    {/*@bgen(jjtree) variable */
        try {
/*@egen*/
	( (exitLine())* <openvariable> type() id() <endvariable> (exitLine())* )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

	// type consists of a word
    void type():
    {/*@bgen(jjtree) type */
     SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) type */
        try {
/*@egen*/
	( (exitLine())* <openType> (exitLine())*  t=<WORD> (exitLine())* <endType> (exitLine())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image); 		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

	// id consists of a word
    void id():
    {/*@bgen(jjtree) id */
     SimpleNode jjtn000 = new SimpleNode(JJTID);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) id */
        try {
/*@egen*/
	( (exitLine())* <openID> (exitLine())* t=<WORD> (exitLine())* <endID> (exitLine())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

	// rule list has number of rules
    void ruleList()       :
    {}
    { 
	(ruleLine())*
    }

	// each rule has a name which is unique across the rule set and consists of an if line and then line
    void ruleLine():
    {/*@bgen(jjtree) ruleLine */
     SimpleNode jjtn000 = new SimpleNode(JJTRULELINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) ruleLine */
        try {
/*@egen*/ 
	((exitLine())* (<openruleattr> t=<WORD> <RA>) salienceLine() ifLine() thenLine() urlLine() <endrule> (exitLine())*)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
    
    // if line has a list of conditions
    void salienceLine():
    {/*@bgen(jjtree) salienceLine */
     SimpleNode jjtn000 = new SimpleNode(JJTSALIENCELINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) salienceLine */
        try {
/*@egen*/ 
	((exitLine())* <opensalience> (exitLine())* t=<WORD> (exitLine())* <endsalience> (exitLine())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
	
	// if line has a list of conditions
    void ifLine():
    {/*@bgen(jjtree) ifLine */
  SimpleNode jjtn000 = new SimpleNode(JJTIFLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
    {/*@bgen(jjtree) ifLine */
        try {
/*@egen*/ 
	((exitLine())* <openif> conditionList() <endif> (exitLine())* )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

	// Condition list consists of number of conditions
    void conditionList()       :
    {}
    { 
	( (exitLine())* <openconditionlist> condition() <endconditionlist> (exitLine())*)
    }
    
    // Each condition has a name and consists of word which defines complex conditions   
    void condition():
    {/*@bgen(jjtree) condition */
     SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) condition */
        try {
/*@egen*/ 
	( (exitLine())* (<opencondition> | <openconditionattr> <WORD> <RA>) (exitLine())* t=<WORD> (exitLine())* <endcondition> (exitLine())*)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
    
    // Then line consists of list of consequences
    void thenLine():
    {/*@bgen(jjtree) thenLine */
  SimpleNode jjtn000 = new SimpleNode(JJTTHENLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
    {/*@bgen(jjtree) thenLine */
        try {
/*@egen*/ 
	((exitLine())* <openthen> consequenceList() <endthen> (exitLine())*)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }

	// consequences list consists of number of consequences
    void consequenceList()       :
    {}
    { 
	((exitLine())* <openconsequencelist> (consequenceLine())* <endconsequencelist> (exitLine())*)
    }
   
    void consequenceLine()       :
    {}
    { 
	( consequence() )
    }

	// Each consequence has a name and consists of word that defines the consequence to be executed when the condition is satisfied
    void consequence():
    {/*@bgen(jjtree) consequence */
     SimpleNode jjtn000 = new SimpleNode(JJTCONSEQUENCE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
    {/*@bgen(jjtree) consequence */
        try {
/*@egen*/ 
	((exitLine())* (<openconsequence> | <openconsequenceattr> <WORD> <RA>) (exitLine())* t=<WORD> (exitLine())* <endconsequence> (exitLine())*)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
    
    void urlLine():
    {/*@bgen(jjtree) urlLine */
     SimpleNode jjtn000 = new SimpleNode(JJTURLLINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t=new Token();}
    {/*@bgen(jjtree) urlLine */
        try {
/*@egen*/ 
	((exitLine())* <openurl> (t=<WORD>)? <endurl> (exitLine())*)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setToken(t.kind, t.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    }
    
    // Exit line defines the terminating characters or characters to be ignored in a rule
    void exitLine()       :
    {}
    {
	(<SPC> | <CRLF>)
    }


    SKIP : { "\n" | "\r" | "\t" }

    TOKEN : 
    {
    	< LA  : "<" > 
    |
    	< RA  : ">" >
    |
    	< SLASH  : "/" >
    |
    	< openruleset  : "<ruleset>" >
    |
    	< openrulesetattr  : "<ruleset name=" >
    |
    	< endruleset  : "</ruleset>" >
    |
    	< openvariables  : "<variable-list>" >
    |
    	< endvariables  : "</variable-list>" >
    |
    	< openvariable  : "<variable>" >
    |
    	< openvariableattr  : "<variable name=" >
    |
    	< endvariable  : "</variable>" >
    |
    	< openType  : "<type>" >
    |
    	< endType  : "</type>" >
    |
    	< openID  : "<id>" >
    |
    	< endID  : "</id>" >
    |
    	< openrule  : "<rule>" >
    |
    	< openruleattr  : "<rule name=" >
    |
    	< endrule  : "</rule>" >
    |	
    	< opensalience : "<salience>">
    |	
    	< endsalience : "</salience>">
    |
    	< openif  : "<if>" >
    |
    	< endif  : "</if>" >
    |
    	< openconditionlist  : "<condition-list>" >
    |
    	< endconditionlist  : "</condition-list>" >
    |
    	< opencondition  : "<condition>" >
    |
    	< openconditionattr  : "<condition name=" >
    |
    	< endcondition  : "</condition>" >
    |
    	< openoperator  : "<operator>" >
    |
    	< openoperatorattr  : "<operator name=" >
    | 
    	< endoperator  : "</operator>" >
    |
    	< openthen  : "<then>" >
    |
    	< endthen  : "</then>" >
    |	
    	< openurl	: "<url>">
    |	
    	< endurl	: "</url>">
    |
    	< openconsequencelist  : "<consequence-list>" >
    |
    	< endconsequencelist  : "</consequence-list>" >
    |
    	< openconsequence  : "<consequence>" >
    |
    	< openconsequenceattr  : "<consequence name=" >
    |
    	< endconsequence  : "</consequence>" >
    |
    	< DIGITS : ( ["0" - "9"] )+  > 
    |
    	< WORD   : ( ["a"-"z" , "A"-"Z" , "," , "0"-"9" , "-" , "=" , "." , "\"" , " " ,"(" ,")", "&" , ";" , "|" , "!" , ":" , "/" , "\\"])+ >
    |
    	< SPC   : ( [" ", "\t"])+ >
    |
   		< CRLF   : ( ["\r","\n"])+ >
   	|	
   		< ESC   : ( ["\"", "\'"])+ >    	
  } 
 
 